# Django REST Framework - Complete Beginner's Guide
**Your Personal Learning Resource**

---

## Table of Contents
1. [Foundations](#foundations)
2. [Your Project Structure](#your-project-structure)
3. [Deep Dive Into Components](#deep-dive-into-components)
4. [Request Flow Walkthrough](#request-flow-walkthrough)
5. [Practical Knowledge](#practical-knowledge)
6. [Next Steps](#next-steps)

---

## Foundations

### What is Django?

Think of Django as a **toolkit for building websites**. Just like a carpenter has tools to build furniture, Django provides tools to build web applications.

**Key Features:**
- **Built with Python** - Uses the Python programming language
- **Batteries included** - Comes with many features pre-built (user authentication, database management, admin panel, etc.)
- **Follows best practices** - Encourages organized, secure, and maintainable code

**Real-world analogy:** If you were building a house, you could cut every piece of wood yourself, make your own nails, etc. OR you could use pre-made materials and tools. Django is like having those pre-made tools for web development.

### What is Django REST Framework (DRF)?

**REST** stands for **Representational State Transfer** - a fancy way of saying "a standardized way for applications to talk to each other over the internet."

**Django REST Framework** is an extension of Django that makes it easy to build **APIs** (Application Programming Interfaces).

**What's an API?**
An API is like a waiter at a restaurant:
- **You (frontend/client):** Order food (make a request)
- **Waiter (API):** Takes your order to the kitchen
- **Kitchen (backend/database):** Prepares the food
- **Waiter (API):** Brings food back to you (sends response)

### Understanding HTTP Methods

When you interact with a web API, you use different **HTTP methods** (also called verbs):

| HTTP Method | Purpose | Restaurant Analogy |
|-------------|---------|-------------------|
| **GET** | Retrieve data | "Show me the menu" |
| **POST** | Create new data | "I'd like to order a burger" |
| **PUT** | Update entire resource | "Change my entire order to a salad" |
| **PATCH** | Update part of resource | "Add extra cheese to my burger" |
| **DELETE** | Remove data | "Cancel my order" |

### HTTP Status Codes

When the API responds, it sends a **status code** to tell you what happened:

| Code | Meaning | Example |
|------|---------|---------|
| **200 OK** | Success | "Here's your data" |
| **201 Created** | Successfully created | "Your new project was created" |
| **204 No Content** | Success, no data to return | "Project deleted successfully" |
| **400 Bad Request** | Your request has errors | "You forgot to include the project name" |
| **404 Not Found** | Resource doesn't exist | "There's no project with ID 999" |
| **500 Server Error** | Server crashed | "Oops, something broke on our end" |

### Django MVT Architecture

Django uses **MVT** (Model-View-Template):

```
┌─────────────────────────────────────────────────────────┐
│                     WEB BROWSER                          │
│              (User visits a URL)                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                    URL ROUTER                            │
│         (urls.py - "Which view handles this?")           │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                      VIEW                                │
│    (views.py - Business logic, process request)          │
│                       │                                  │
│         ┌─────────────┴──────────────┐                  │
│         ▼                            ▼                   │
│    ┌─────────┐                  ┌─────────┐             │
│    │  MODEL  │                  │TEMPLATE │             │
│    │(models) │                  │  (HTML) │             │
│    │Database │                  │         │             │
│    └─────────┘                  └─────────┘             │
└─────────────────────┬───────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                   RESPONSE                               │
│         (JSON data or HTML page)                         │
└─────────────────────────────────────────────────────────┘
```

**For REST APIs (like yours):**
- **Model:** Defines database structure (what data looks like)
- **View:** Contains business logic (what to do with the data)
- **Serializer** (instead of Template): Converts data to JSON format

---

## Your Project Structure

### Directory Overview

```
backend/
├── manage.py                 # Command-line tool for Django
├── db.sqlite3               # Your database file (created after migrations)
├── backend/                 # Main project folder
│   ├── __init__.py         # Makes this a Python package
│   ├── settings.py         # All project settings/configuration
│   ├── urls.py             # Main URL routing (traffic director)
│   ├── wsgi.py             # Web server gateway (for production)
│   └── asgi.py             # Async server gateway (for production)
└── projects/               # Your "projects" app
    ├── __init__.py         # Makes this a Python package
    ├── models.py           # Database structure (Project model)
    ├── serializers.py      # Data conversion (Python ↔ JSON)
    ├── views.py            # Business logic (CRUD operations)
    ├── urls.py             # App-specific URL patterns
    ├── admin.py            # Django admin customization
    ├── apps.py             # App configuration
    ├── tests.py            # Unit tests (for testing your code)
    └── migrations/         # Database change history
        └── 0001_initial.py # First migration (creates Project table)
```

### Key Concepts

**manage.py** - Your command center
```bash
python manage.py runserver    # Start development server
python manage.py migrate       # Apply database changes
python manage.py createsuperuser  # Create admin user
python manage.py makemigrations   # Create new migration files
```

**Django Project vs Django App**
- **Project** (backend/): The entire website/API
- **App** (projects/): A component of the project (like a module)
- One project can have many apps (e.g., projects, users, comments, etc.)

**Why separate apps?**
Think of apps like rooms in a house:
- **projects/** app handles projects
- **users/** app (if you add it) handles user accounts
- **comments/** app (if you add it) handles comments

Each app is self-contained and reusable!

---

## Deep Dive Into Components

### 1. Models (models.py) - The Database Blueprint

**Location:** `projects/models.py`

```python
from django.db import models

class Project(models.Model):
    name = models.CharField(max_length=120)
    description = models.TextField(blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

**What is this doing?**

Think of this as creating a **blueprint for a database table**:

```
projects_project table:
┌────┬──────────────┬─────────────┬───────────┬─────────────────────┬─────────────────────┐
│ id │ name         │ description │ is_active │ created_at          │ updated_at          │
├────┼──────────────┼─────────────┼───────────┼─────────────────────┼─────────────────────┤
│ 1  │ "My Project" │ "A cool..." │ true      │ 2025-01-15 10:30:00 │ 2025-01-15 10:30:00 │
│ 2  │ "Website"    │ "Personal...│ true      │ 2025-01-16 14:20:00 │ 2025-01-16 14:20:00 │
└────┴──────────────┴─────────────┴───────────┴─────────────────────┴─────────────────────┘
```

**Line-by-line explanation:**

```python
class Project(models.Model):
```
- `class` - Defining a Python class (like a template)
- `Project` - The name of your model
- `(models.Model)` - Inherits from Django's Model class (gets superpowers!)

```python
name = models.CharField(max_length=120)
```
- `name` - Field name (column in database)
- `CharField` - Field type (stores text)
- `max_length=120` - Maximum 120 characters allowed

```python
description = models.TextField(blank=True)
```
- `TextField` - For longer text (like a paragraph)
- `blank=True` - This field is optional (can be empty)

```python
is_active = models.BooleanField(default=True)
```
- `BooleanField` - True or False value
- `default=True` - If not specified, defaults to True

```python
created_at = models.DateTimeField(auto_now_add=True)
```
- `DateTimeField` - Stores date and time
- `auto_now_add=True` - Automatically set when object is created (never changes)

```python
updated_at = models.DateTimeField(auto_now=True)
```
- `auto_now=True` - Automatically updates every time object is saved

```python
def __str__(self):
    return self.name
```
- Special method that returns a string representation
- When you print a Project object, you'll see its name
- Used in Django admin and debugging

### 2. Serializers (serializers.py) - The Translator

**Location:** `projects/serializers.py`

```python
from rest_framework import serializers
from .models import Project

class ProjectSerializer(serializers.ModelSerializer):
    class Meta:
        model = Project
        fields = ["id", "name", "description", "is_active", "created_at", "updated_at"]
        read_only_fields = ["id", "created_at", "updated_at"]
```

**What is a Serializer?**

A serializer is like a **translator** between two languages:

```
Python Object          JSON (for API)
┌─────────────┐       ┌──────────────────────┐
│ Project     │       │ {                    │
│  id = 1     │  ←→   │   "id": 1,           │
│  name = "X" │       │   "name": "X",       │
│  is_active  │       │   "is_active": true  │
│    = True   │       │ }                    │
└─────────────┘       └──────────────────────┘
```

**Why do we need this?**
- Browsers and apps speak JSON (JavaScript Object Notation)
- Django/Python speaks Python objects
- Serializers convert between them!

**Line-by-line explanation:**

```python
class ProjectSerializer(serializers.ModelSerializer):
```
- Creates a serializer class
- `ModelSerializer` - Special type that works with Django models

```python
class Meta:
```
- Meta class contains configuration/metadata

```python
model = Project
```
- Which model this serializer is for

```python
fields = ["id", "name", "description", "is_active", "created_at", "updated_at"]
```
- Which fields to include when converting to JSON
- These must match fields in your model

```python
read_only_fields = ["id", "created_at", "updated_at"]
```
- These fields cannot be modified by users
- `id` - Automatically generated by database
- `created_at` - Set once when created
- `updated_at` - Automatically updated by Django

**What happens during serialization:**

**1. Serializing (Python → JSON):**
```python
# In your view
project = Project.objects.get(id=1)
serializer = ProjectSerializer(project)
# serializer.data is now JSON
```

**2. Deserializing (JSON → Python):**
```python
# In your view
data = {"name": "New Project", "description": "Cool project"}
serializer = ProjectSerializer(data=data)
if serializer.is_valid():
    project = serializer.save()  # Creates Project object
```

### 3. Views (views.py) - The Brain

**Location:** `projects/views.py`

```python
from django.shortcuts import get_object_or_404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

from .models import Project
from .serializers import ProjectSerializer


class ProjectListCreate(APIView):
    """
    GET /api/projects/  -> list all projects
    POST /api/projects/ -> create new project
    """
    def get(self, request):
        queryset = Project.objects.all().order_by("-created_at")
        serializer = ProjectSerializer(queryset, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        serializer = ProjectSerializer(data=request.data)
        if serializer.is_valid():
            instance = serializer.save()
            return Response(ProjectSerializer(instance).data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ProjectDetail(APIView):
    """
    GET /api/projects/<id>/    -> retrieve one project
    PUT /api/projects/<id>/    -> full update
    PATCH /api/projects/<id>/  -> partial update
    DELETE /api/projects/<id>/ -> delete
    """
    def get_object(self, pk):
        return get_object_or_404(Project, pk=pk)

    def get(self, request, pk: int):
        project = self.get_object(pk)
        serializer = ProjectSerializer(project)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def put(self, request, pk: int):
        project = self.get_object(pk)
        serializer = ProjectSerializer(project, data=request.data)
        if serializer.is_valid():
            instance = serializer.save()
            return Response(ProjectSerializer(instance).data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def patch(self, request, pk: int):
        project = self.get_object(pk)
        serializer = ProjectSerializer(project, data=request.data, partial=True)
        if serializer.is_valid():
            instance = serializer.save()
            return Response(ProjectSerializer(instance).data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request, pk: int):
        project = self.get_object(pk)
        project.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

**What are Views?**

Views contain your **business logic** - the code that processes requests and returns responses.

**Class-Based Views (APIView)**

You're using `APIView` from DRF. It's like a container with methods for each HTTP method:

```python
class ProjectListCreate(APIView):
    def get(self, request):       # Handles GET requests
        # ... code ...

    def post(self, request):      # Handles POST requests
        # ... code ...
```

**Detailed breakdown of GET request (List all projects):**

```python
def get(self, request):
    # Step 1: Query the database
    queryset = Project.objects.all().order_by("-created_at")

    # Step 2: Serialize the data (Python → JSON)
    serializer = ProjectSerializer(queryset, many=True)

    # Step 3: Return JSON response
    return Response(serializer.data, status=status.HTTP_200_OK)
```

**Line by line:**

```python
queryset = Project.objects.all().order_by("-created_at")
```
- `Project.objects.all()` - Get ALL projects from database
- `.order_by("-created_at")` - Sort by creation date, newest first (the `-` means descending)
- `queryset` - A lazy collection of database records

```python
serializer = ProjectSerializer(queryset, many=True)
```
- Create a serializer with the queryset
- `many=True` - We're serializing multiple objects (not just one)
- Converts Python objects to JSON-ready format

```python
return Response(serializer.data, status=status.HTTP_200_OK)
```
- `Response()` - DRF's response object
- `serializer.data` - The JSON data
- `status.HTTP_200_OK` - HTTP status code 200

**Detailed breakdown of POST request (Create new project):**

```python
def post(self, request):
    # Step 1: Create serializer with incoming data
    serializer = ProjectSerializer(data=request.data)

    # Step 2: Validate the data
    if serializer.is_valid():
        # Step 3: Save to database
        instance = serializer.save()

        # Step 4: Return the created object
        return Response(ProjectSerializer(instance).data, status=status.HTTP_201_CREATED)

    # If validation fails, return errors
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

**What is `request.data`?**
When you POST JSON from Postman, it arrives as `request.data`:
```python
request.data = {
    "name": "My Project",
    "description": "A cool project",
    "is_active": true
}
```

**Validation:**
```python
if serializer.is_valid():
```
DRF checks:
- Are all required fields present?
- Is `name` less than 120 characters?
- Is `is_active` a boolean?
- etc.

**Detailed breakdown of PUT vs PATCH:**

**PUT (Full Update):**
```python
serializer = ProjectSerializer(project, data=request.data)
```
- Requires ALL fields to be sent
- Replaces entire object

**PATCH (Partial Update):**
```python
serializer = ProjectSerializer(project, data=request.data, partial=True)
```
- `partial=True` - Only update fields that are sent
- Can send just `{"name": "New Name"}` without other fields

**Detailed breakdown of DELETE:**

```python
def delete(self, request, pk: int):
    project = self.get_object(pk)  # Get the project
    project.delete()                # Delete it from database
    return Response(status=status.HTTP_204_NO_CONTENT)  # Return 204 (no content)
```

### 4. URLs (urls.py) - The Traffic Director

**Main URLs:** `backend/urls.py`

```python
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    path("admin/", admin.site.urls),

    # JWT endpoints (for authentication)
    path("api/auth/jwt/create/", TokenObtainPairView.as_view(), name="jwt-create"),
    path("api/auth/jwt/refresh/", TokenRefreshView.as_view(), name="jwt-refresh"),

    # Include all URLs from projects app
    path("api/", include("projects.urls")),
]
```

**What is this doing?**

Think of URLs as a **switchboard operator**:
- User requests a URL
- Django checks `urlpatterns` from top to bottom
- When it finds a match, it routes to that view

**Breakdown:**

```python
path("admin/", admin.site.urls)
```
- Any URL starting with `/admin/` goes to Django's admin panel
- Example: `http://127.0.0.1:8000/admin/`

```python
path("api/auth/jwt/create/", TokenObtainPairView.as_view(), name="jwt-create")
```
- URL pattern: `/api/auth/jwt/create/`
- Routes to `TokenObtainPairView` (creates JWT tokens for authentication)
- `name="jwt-create"` - Internal name for referencing this URL

```python
path("api/", include("projects.urls"))
```
- Any URL starting with `/api/` is passed to `projects/urls.py`
- `include()` - Include another URL configuration
- Example: `/api/projects/` → looks in `projects/urls.py` for `projects/`

**App URLs:** `projects/urls.py`

```python
from django.urls import path
from .views import ProjectListCreate, ProjectDetail

urlpatterns = [
    path("projects/", ProjectListCreate.as_view(), name="project-list-create"),
    path("projects/<int:pk>/", ProjectDetail.as_view(), name="project-detail"),
]
```

**How URL routing works:**

Request: `GET http://127.0.0.1:8000/api/projects/`

```
1. Django checks main urls.py:
   - Matches: path("api/", include("projects.urls"))
   - Remaining: "projects/"

2. Django checks projects/urls.py:
   - Matches: path("projects/", ProjectListCreate.as_view())
   - Calls: ProjectListCreate.get(request)
```

Request: `GET http://127.0.0.1:8000/api/projects/5/`

```
1. Django checks main urls.py:
   - Matches: path("api/", include("projects.urls"))
   - Remaining: "projects/5/"

2. Django checks projects/urls.py:
   - Matches: path("projects/<int:pk>/", ProjectDetail.as_view())
   - <int:pk> captures "5" as pk=5
   - Calls: ProjectDetail.get(request, pk=5)
```

**What is `<int:pk>`?**
- `<int:pk>` - URL parameter (captures an integer)
- `pk` - Parameter name (primary key)
- The value is passed to your view method

### 5. Settings (settings.py) - The Configuration Hub

**Location:** `backend/settings.py`

This file contains ALL configuration for your Django project.

**Key Settings Explained:**

```python
BASE_DIR = Path(__file__).resolve().parent.parent
```
- The root directory of your project
- Used to build absolute file paths

```python
SECRET_KEY = 'django-insecure-your-secret-key-change-this-in-production'
```
- Secret key for cryptographic signing
- **MUST** be changed in production
- Used for security features (sessions, password reset tokens, etc.)

```python
DEBUG = True
```
- `True` - Show detailed error pages (for development)
- **MUST** be `False` in production (hides sensitive info)

```python
ALLOWED_HOSTS = []
```
- List of host/domain names that Django can serve
- Empty in development (allows all)
- In production: `['yourdomain.com', 'www.yourdomain.com']`

```python
INSTALLED_APPS = [
    'django.contrib.admin',      # Admin panel
    'django.contrib.auth',       # Authentication system
    'django.contrib.contenttypes',  # Content type system
    'django.contrib.sessions',   # Session framework
    'django.contrib.messages',   # Messaging framework
    'django.contrib.staticfiles',  # Static files management

    'rest_framework',    # Django REST Framework
    'corsheaders',       # CORS headers (for frontend access)

    'projects',          # Your projects app
]
```
- List of all apps in your project
- Django apps (built-in functionality)
- Third-party apps (from pip)
- Your apps (custom functionality)

```python
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # MUST be first
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```
- Middleware processes requests/responses
- Think of it as a **series of filters** that every request passes through

```python
ROOT_URLCONF = 'backend.urls'
```
- Points to your main URL configuration
- Tells Django where to find URL patterns

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
- Database configuration
- Using SQLite (simple file-based database)
- Perfect for development
- For production, use PostgreSQL or MySQL

```python
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",   # Vite dev server
    "http://127.0.0.1:5173",
]
```
- CORS (Cross-Origin Resource Sharing)
- Allows your Vue frontend to access the API
- Lists allowed origins (frontend URLs)

```python
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.AllowAny",
    ],
}
```
- DRF configuration
- Authentication: How users prove who they are
- Permissions: Who can access what
- `AllowAny` - No authentication required (change this later!)

```python
STATIC_URL = "/static/"
```
- URL prefix for static files (CSS, JS, images)
- Example: `/static/css/style.css`

```python
TIME_ZONE = "Europe/Oslo"
USE_TZ = True
```
- Your timezone
- `USE_TZ = True` - Store times in UTC, convert to local timezone

---

## Request Flow Walkthrough

Let's trace what happens when you make a request to your API.

### Example: Creating a Project via POST

**Step-by-step flow:**

```
YOU (via Postman)
       │
       │ POST http://127.0.0.1:8000/api/projects/
       │ Body: {"name": "My Project", "description": "Cool"}
       │
       ▼
┌──────────────────────────────────────────────────┐
│ 1. Django receives request                       │
│    - Parses URL, method, headers, body          │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 2. MIDDLEWARE processing                         │
│    - CORS check (is frontend allowed?)          │
│    - Security checks                             │
│    - Session handling                            │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 3. URL ROUTING (backend/urls.py)                 │
│    - Matches: path("api/", include(...))         │
│    - Remaining path: "projects/"                 │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 4. URL ROUTING (projects/urls.py)                │
│    - Matches: path("projects/", ...)             │
│    - Routes to: ProjectListCreate view           │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 5. VIEW (ProjectListCreate.post())               │
│                                                  │
│    request.data = {                              │
│        "name": "My Project",                     │
│        "description": "Cool"                     │
│    }                                             │
│                                                  │
│    # Create serializer                           │
│    serializer = ProjectSerializer(               │
│        data=request.data                         │
│    )                                             │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 6. SERIALIZER validates data                     │
│    - Is "name" present? ✓                        │
│    - Is "name" <= 120 chars? ✓                   │
│    - Is "description" valid text? ✓              │
│    - Returns: is_valid() = True                  │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 7. SAVE to database                              │
│    instance = serializer.save()                  │
│                                                  │
│    SQL executed:                                 │
│    INSERT INTO projects_project                  │
│    (name, description, is_active,                │
│     created_at, updated_at)                      │
│    VALUES                                        │
│    ('My Project', 'Cool', true,                  │
│     '2025-01-15 10:30:00', '2025-01-15 10:30:00')│
│                                                  │
│    Returns: Project object (id=1)                │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 8. SERIALIZE response                            │
│    ProjectSerializer(instance).data              │
│                                                  │
│    Converts to:                                  │
│    {                                             │
│        "id": 1,                                  │
│        "name": "My Project",                     │
│        "description": "Cool",                    │
│        "is_active": true,                        │
│        "created_at": "2025-01-15T10:30:00Z",     │
│        "updated_at": "2025-01-15T10:30:00Z"      │
│    }                                             │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 9. RETURN Response                               │
│    Response(data, status=201)                    │
└──────────────┬───────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────┐
│ 10. MIDDLEWARE (outgoing)                        │
│     - Add headers                                │
│     - CORS headers                               │
└──────────────┬───────────────────────────────────┘
               │
               ▼
         YOU (via Postman)
         Receives:
         Status: 201 Created
         Body: {
           "id": 1,
           "name": "My Project",
           ...
         }
```

### Example: Getting All Projects via GET

**Step-by-step:**

```
YOU: GET http://127.0.0.1:8000/api/projects/
       │
       ▼
URL Routing → ProjectListCreate.get()
       │
       ▼
┌──────────────────────────────────────┐
│ queryset = Project.objects.all()     │
│   .order_by("-created_at")           │
│                                      │
│ SQL: SELECT * FROM projects_project  │
│      ORDER BY created_at DESC        │
│                                      │
│ Returns: [Project(id=2), Project(id=1)]│
└──────────┬───────────────────────────┘
           │
           ▼
┌──────────────────────────────────────┐
│ serializer = ProjectSerializer(      │
│     queryset, many=True              │
│ )                                    │
│                                      │
│ Converts to:                         │
│ [                                    │
│   {"id": 2, "name": "Project 2", ...},│
│   {"id": 1, "name": "My Project", ...}│
│ ]                                    │
└──────────┬───────────────────────────┘
           │
           ▼
    Return Response
    Status: 200 OK
    Body: [list of projects]
```

### Example: Updating a Project via PATCH

```
YOU: PATCH http://127.0.0.1:8000/api/projects/1/
     Body: {"name": "Updated Name"}
       │
       ▼
URL Routing → ProjectDetail.patch(pk=1)
       │
       ▼
┌──────────────────────────────────────┐
│ project = get_object_or_404(Project, pk=1) │
│                                      │
│ SQL: SELECT * FROM projects_project  │
│      WHERE id = 1                    │
│                                      │
│ Returns: Project(id=1, name="My Project")│
└──────────┬───────────────────────────┘
           │
           ▼
┌──────────────────────────────────────┐
│ serializer = ProjectSerializer(      │
│     project,                         │
│     data={"name": "Updated Name"},   │
│     partial=True  ← KEY!             │
│ )                                    │
│                                      │
│ Validates: name is valid             │
└──────────┬───────────────────────────┘
           │
           ▼
┌──────────────────────────────────────┐
│ instance = serializer.save()         │
│                                      │
│ SQL: UPDATE projects_project         │
│      SET name = 'Updated Name',      │
│          updated_at = NOW()          │
│      WHERE id = 1                    │
└──────────┬───────────────────────────┘
           │
           ▼
    Return Response
    Status: 200 OK
    Body: {updated project data}
```

### Example: Deleting a Project

```
YOU: DELETE http://127.0.0.1:8000/api/projects/1/
       │
       ▼
URL Routing → ProjectDetail.delete(pk=1)
       │
       ▼
┌──────────────────────────────────────┐
│ project = get_object_or_404(Project, pk=1) │
│ project.delete()                     │
│                                      │
│ SQL: DELETE FROM projects_project    │
│      WHERE id = 1                    │
└──────────┬───────────────────────────┘
           │
           ▼
    Return Response
    Status: 204 No Content
    Body: (empty)
```

---

## Practical Knowledge

### Testing with Postman

**1. List All Projects**
```
Method: GET
URL: http://127.0.0.1:8000/api/projects/
Headers: (none needed)
Body: (none)

Expected Response:
Status: 200 OK
Body:
[
  {
    "id": 1,
    "name": "Project 1",
    "description": "Description here",
    "is_active": true,
    "created_at": "2025-01-15T10:30:00Z",
    "updated_at": "2025-01-15T10:30:00Z"
  }
]
```

**2. Create a Project**
```
Method: POST
URL: http://127.0.0.1:8000/api/projects/
Headers:
  Content-Type: application/json
Body (raw JSON):
{
  "name": "My New Project",
  "description": "This is a test project",
  "is_active": true
}

Expected Response:
Status: 201 Created
Body: (same as above with new id)
```

**3. Get Single Project**
```
Method: GET
URL: http://127.0.0.1:8000/api/projects/1/
(Replace 1 with actual project ID)

Expected Response:
Status: 200 OK
Body: (single project object)
```

**4. Update Project (Full)**
```
Method: PUT
URL: http://127.0.0.1:8000/api/projects/1/
Headers:
  Content-Type: application/json
Body (raw JSON):
{
  "name": "Updated Project",
  "description": "Updated description",
  "is_active": false
}

Expected Response:
Status: 200 OK
Body: (updated project)
```

**5. Update Project (Partial)**
```
Method: PATCH
URL: http://127.0.0.1:8000/api/projects/1/
Headers:
  Content-Type: application/json
Body (raw JSON):
{
  "name": "Only changing name"
}

Expected Response:
Status: 200 OK
Body: (updated project with only name changed)
```

**6. Delete Project**
```
Method: DELETE
URL: http://127.0.0.1:8000/api/projects/1/

Expected Response:
Status: 204 No Content
Body: (empty)
```

### Database Migrations Explained

**What are migrations?**

Migrations are like **version control for your database schema**. Every time you change your models, you create a migration.

**Why migrations?**
- Track database changes over time
- Apply changes consistently across environments
- Rollback if needed
- Share changes with team

**Common commands:**

```bash
# 1. Create migration files (after changing models)
python manage.py makemigrations

# 2. Apply migrations to database
python manage.py migrate

# 3. See migration status
python manage.py showmigrations

# 4. See SQL that will be executed
python manage.py sqlmigrate projects 0001
```

**Migration workflow:**

```
1. You change models.py
   (e.g., add new field: age = models.IntegerField())

2. Run: python manage.py makemigrations
   Creates: projects/migrations/0002_auto_20250115_1030.py

   This file contains Python code describing the change

3. Run: python manage.py migrate
   Executes SQL: ALTER TABLE projects_project ADD COLUMN age INTEGER

4. Database is updated!
```

**Your first migration** (`0001_initial.py`):

This migration created your `projects_project` table when you first ran `migrate`.

### Common Errors and Solutions

**1. "ModuleNotFoundError: No module named 'X'"**
```
Solution: pip install X
(You need to install the package)
```

**2. "You have X unapplied migration(s)"**
```
Solution: python manage.py migrate
(Apply pending migrations)
```

**3. "CSRF verification failed"**
```
Solution: You're using session authentication with browser
- Either disable CSRF for API (not recommended)
- Or use JWT authentication
- Or include CSRF token in requests
```

**4. "No such table: projects_project"**
```
Solution: python manage.py migrate
(You haven't created the database tables)
```

**5. "404 Not Found on /"**
```
This is normal! Your API doesn't have a view for /
Visit /api/projects/ instead
```

**6. "CORS error in browser console"**
```
Solution: Check CORS_ALLOWED_ORIGINS in settings.py
Make sure your frontend URL is listed
```

### Important Django Concepts

**QuerySets**

A QuerySet is a lazy collection of database queries:

```python
# These don't hit the database yet (lazy)
projects = Project.objects.all()
active_projects = Project.objects.filter(is_active=True)
recent_projects = Project.objects.order_by("-created_at")[:5]

# Database is hit when you:
list(projects)           # Convert to list
for p in projects: ...   # Iterate
serializer = ProjectSerializer(projects, many=True)  # Serialize
```

**Common QuerySet methods:**

```python
# Get all
Project.objects.all()

# Filter (WHERE)
Project.objects.filter(is_active=True)
Project.objects.filter(name__contains="Test")  # LIKE '%Test%'

# Get one object (raises error if not found)
Project.objects.get(id=1)

# Get or 404
from django.shortcuts import get_object_or_404
get_object_or_404(Project, id=1)

# Exclude (NOT)
Project.objects.exclude(is_active=False)

# Order by
Project.objects.order_by("name")        # ASC
Project.objects.order_by("-created_at") # DESC

# Count
Project.objects.count()

# Exists
Project.objects.filter(name="Test").exists()

# Create
Project.objects.create(name="New Project", description="...")

# Update
project = Project.objects.get(id=1)
project.name = "Updated"
project.save()

# Delete
project = Project.objects.get(id=1)
project.delete()
```

**Django Admin**

Django comes with a free admin panel!

**1. Create superuser:**
```bash
python manage.py createsuperuser
# Enter username, email, password
```

**2. Register your model** (`projects/admin.py`):
```python
from django.contrib import admin
from .models import Project

@admin.register(Project)
class ProjectAdmin(admin.ModelAdmin):
    list_display = ["id", "name", "is_active", "created_at"]
    list_filter = ["is_active", "created_at"]
    search_fields = ["name", "description"]
```

**3. Visit:** http://127.0.0.1:8000/admin/

**4. Login** with your superuser credentials

**5. You can now:**
- View all projects
- Create new projects
- Edit existing projects
- Delete projects
- All with a nice UI!

---

## Next Steps

### Immediate Next Steps

**1. Add Authentication**

Currently, your API allows anyone to do anything (`AllowAny`). Add proper authentication:

```python
# In views.py
from rest_framework.permissions import IsAuthenticated

class ProjectListCreate(APIView):
    permission_classes = [IsAuthenticated]  # Require login
    # ... rest of code
```

**2. Add User Association**

Link projects to users:

```python
# In models.py
from django.contrib.auth.models import User

class Project(models.Model):
    owner = models.ForeignKey(User, on_delete=models.CASCADE)
    # ... other fields
```

**3. Add Pagination**

Return results in pages (instead of all at once):

```python
from rest_framework.pagination import PageNumberPagination

class ProjectPagination(PageNumberPagination):
    page_size = 10
```

**4. Add Filtering and Search**

Let users filter by status, search by name, etc.

**5. Add Tests**

Write automated tests to ensure your code works:

```python
# In tests.py
from rest_framework.test import APITestCase

class ProjectAPITests(APITestCase):
    def test_create_project(self):
        response = self.client.post("/api/projects/", {
            "name": "Test Project",
            "description": "Test"
        })
        self.assertEqual(response.status_code, 201)
```

### Learning Resources

**Official Documentation:**
- Django Docs: https://docs.djangoproject.com/
- DRF Docs: https://www.django-rest-framework.org/

**Tutorials:**
- Django Girls Tutorial: https://tutorial.djangogirls.org/
- DRF Quickstart: https://www.django-rest-framework.org/tutorial/quickstart/
- Real Python Django: https://realpython.com/tutorials/django/

**Books:**
- "Django for Beginners" by William S. Vincent
- "Two Scoops of Django" (best practices)

**Practice Projects:**
- Build a Blog API
- Build a Todo List API
- Build a Social Media API

### Key Concepts to Study Further

**1. Django ORM (Object-Relational Mapping)**
- More complex queries
- Relationships (ForeignKey, ManyToMany)
- Query optimization

**2. DRF Advanced Topics**
- ViewSets and Routers
- Generic Views
- Permissions and Authentication
- Throttling (rate limiting)

**3. Database Design**
- Normalization
- Indexes
- Relationships
- Migrations

**4. Security**
- HTTPS
- Environment variables (for secrets)
- SQL injection prevention
- XSS and CSRF protection

**5. Deployment**
- Production settings
- Gunicorn/uWSGI
- Nginx
- Docker
- Cloud platforms (Heroku, AWS, DigitalOcean)

---

## Quick Reference

### Useful Commands

```bash
# Development
python manage.py runserver           # Start dev server
python manage.py runserver 0.0.0.0:8000  # Accessible on network

# Database
python manage.py makemigrations      # Create migration files
python manage.py migrate             # Apply migrations
python manage.py showmigrations      # Show migration status
python manage.py dbshell             # Open database shell

# Users
python manage.py createsuperuser     # Create admin user
python manage.py changepassword <username>  # Change password

# Shell
python manage.py shell               # Python shell with Django loaded
python manage.py shell_plus          # Enhanced shell (install django-extensions)

# Static Files
python manage.py collectstatic       # Collect static files for production

# Other
python manage.py check               # Check for issues
python manage.py test                # Run tests
```

### File Structure Cheat Sheet

```
backend/
├── manage.py              # Command-line utility
├── db.sqlite3            # Database (SQLite)
├── backend/              # Project settings
│   ├── settings.py       # Configuration
│   ├── urls.py           # Main URL routing
│   ├── wsgi.py          # WSGI config
│   └── asgi.py          # ASGI config
└── projects/            # Django app
    ├── models.py        # Database models
    ├── serializers.py   # DRF serializers
    ├── views.py         # View logic
    ├── urls.py          # App URLs
    ├── admin.py         # Admin config
    ├── tests.py         # Tests
    └── migrations/      # Migration files
```

### Django/DRF Patterns

**Model → Serializer → View → URL**

1. **Define Model** (what data looks like)
2. **Create Serializer** (how to convert data)
3. **Write View** (what to do with data)
4. **Add URL** (how to access view)

**Always in this order!**

---

## Glossary

**API (Application Programming Interface):**
A way for applications to communicate with each other.

**CRUD:**
Create, Read, Update, Delete - the four basic operations.

**Django:**
A high-level Python web framework.

**DRF (Django REST Framework):**
A toolkit for building Web APIs in Django.

**Endpoint:**
A specific URL in your API (e.g., `/api/projects/`).

**HTTP (HyperText Transfer Protocol):**
The protocol used for communication on the web.

**JSON (JavaScript Object Notation):**
A lightweight data format, easy for humans and machines to read.

**Migration:**
A file describing database schema changes.

**Model:**
A Python class that defines database structure.

**ORM (Object-Relational Mapping):**
A way to interact with databases using Python objects instead of SQL.

**QuerySet:**
A collection of database queries in Django.

**REST (Representational State Transfer):**
An architectural style for APIs.

**Serializer:**
Converts complex data types to/from JSON.

**View:**
A function/class that processes requests and returns responses.

**URL Pattern:**
A route that maps URLs to views.

**WSGI (Web Server Gateway Interface):**
A standard for Python web applications.

---

## Practice Exercises

### Exercise 1: Add a New Field

**Goal:** Add a `budget` field to the Project model.

**Steps:**
1. Add to model: `budget = models.DecimalField(max_digits=10, decimal_places=2, default=0)`
2. Run `makemigrations`
3. Run `migrate`
4. Add `budget` to serializer fields
5. Test in Postman

### Exercise 2: Create a Custom Endpoint

**Goal:** Create an endpoint to get only active projects.

**Hint:**
```python
# In views.py
def get(self, request):
    queryset = Project.objects.filter(is_active=True)
    # ... rest of code
```

### Exercise 3: Add a Stats Endpoint

**Goal:** Create `/api/projects/stats/` that returns project count.

**Hint:**
```python
# In views.py
class ProjectStats(APIView):
    def get(self, request):
        total = Project.objects.count()
        active = Project.objects.filter(is_active=True).count()
        return Response({
            "total_projects": total,
            "active_projects": active
        })

# In urls.py
path("projects/stats/", ProjectStats.as_view())
```

### Exercise 4: Implement Filtering

**Goal:** Allow filtering projects by `is_active` via query parameter.

Example: `/api/projects/?is_active=true`

**Hint:**
```python
def get(self, request):
    queryset = Project.objects.all()

    is_active = request.query_params.get('is_active', None)
    if is_active is not None:
        queryset = queryset.filter(is_active=is_active.lower() == 'true')

    # ... rest of code
```

---

## Full-Stack Integration with Vue.js

### Overview

Your project now includes a Vue.js 3 frontend that communicates with your Django backend API. This creates a **complete full-stack application**!

```
┌────────────────────────────────────────────────────────┐
│                    USER'S BROWSER                       │
│                                                         │
│  ┌──────────────────────────────────────────────────┐ │
│  │         Vue.js 3 Frontend (SPA)                  │ │
│  │         Running on: http://localhost:5173        │ │
│  │                                                   │ │
│  │  ├─ Landing Page (/)                            │ │
│  │  ├─ Projects View (/projects) - Public         │ │
│  │  ├─ About Page (/about) - Public               │ │
│  │  ├─ Admin Login (/admin)                       │ │
│  │  └─ Admin Dashboard (/admin/dashboard) - Auth  │ │
│  └──────────────┬────────────────────────────────────┘ │
│                 │                                       │
│                 │  HTTP Requests (Axios)               │
│                 │  with JWT Token                      │
└─────────────────┼───────────────────────────────────────┘
                  │
                  │  CORS Enabled
                  │
┌─────────────────▼───────────────────────────────────────┐
│          Django REST API Backend                        │
│          Running on: http://localhost:8000              │
│                                                          │
│  ┌────────────────────────────────────────────┐        │
│  │  Public Endpoints (No Auth)                │        │
│  │  ├─ GET /api/projects/                     │        │
│  │  └─ GET /api/projects/:id/                 │        │
│  └────────────────────────────────────────────┘        │
│                                                          │
│  ┌────────────────────────────────────────────┐        │
│  │  Protected Endpoints (Auth Required)        │        │
│  │  ├─ POST /api/projects/                    │        │
│  │  ├─ PUT /api/projects/:id/                 │        │
│  │  ├─ PATCH /api/projects/:id/               │        │
│  │  └─ DELETE /api/projects/:id/              │        │
│  └────────────────────────────────────────────┘        │
│                                                          │
│  ┌────────────────────────────────────────────┐        │
│  │  Authentication Endpoints                   │        │
│  │  ├─ POST /api/auth/jwt/create/ (login)    │        │
│  │  └─ POST /api/auth/jwt/refresh/ (refresh)  │        │
│  └────────────────────────────────────────────┘        │
└──────────────────────────────────────────────────────────┘
```

### What is a Single Page Application (SPA)?

A **Single Page Application** is a web application that:
- Loads once when you visit the site
- Updates content dynamically without page refreshes
- Uses JavaScript to render views
- Communicates with the backend via API calls

**Traditional Multi-Page App vs SPA:**

```
TRADITIONAL:
User clicks link → Browser requests HTML → Server renders HTML →
→ Full page reload → User sees new page

SPA:
User clicks link → JavaScript changes view → Request data from API →
→ Update only changed parts → User sees new content (no reload!)
```

### Vue.js Frontend Structure

**Location:** `frontend/src/`

```
frontend/src/
├── views/                    # Page components
│   ├── LandingView.vue      # Home page (/)
│   ├── ProjectsView.vue     # Public projects (/projects)
│   ├── AboutView.vue        # About page (/about)
│   ├── AdminDashboardView.vue  # Login (/admin)
│   └── HomeView.vue         # Admin dashboard (/admin/dashboard)
├── router/
│   └── index.ts            # Route definitions
├── stores/
│   └── auth.ts            # Authentication state (Pinia)
├── services/
│   └── api.ts            # Axios HTTP client
├── types/
│   └── project.ts       # TypeScript interfaces
└── main.ts             # App entry point
```

---

## JWT Authentication

### What is JWT?

**JWT (JSON Web Token)** is a secure way to transmit information between client and server.

Think of it like a **digital passport**:
- You log in (show your ID)
- Server gives you a JWT (issues passport)
- You include JWT in future requests (show passport)
- Server trusts you without checking credentials again

**JWT Structure:**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIn0.abc123def456
│                                      │                                    │
└──────────────────┬───────────────────┴────────────────────┬──────────────┘
                   │                                         │
                HEADER                                   SIGNATURE
            (algorithm info)                         (verifies authenticity)
                                 PAYLOAD
                            (user data: id, username, etc.)
```

### JWT Authentication Flow in Your Project

```
1. USER LOGS IN
   ┌──────────────────────────────────────────┐
   │ Frontend (AdminDashboardView.vue)        │
   │                                          │
   │ User enters: username + password         │
   │ Clicks "Login" button                    │
   └──────────────┬───────────────────────────┘
                  │
                  ▼
   POST /api/auth/jwt/create/
   Body: { "username": "admin", "password": "admin123" }
                  │
                  ▼
   ┌──────────────────────────────────────────┐
   │ Backend (djangorestframework-simplejwt)  │
   │                                          │
   │ 1. Validates credentials                 │
   │ 2. Generates two tokens:                 │
   │    - access token (short-lived: 5 min)   │
   │    - refresh token (long-lived: 1 day)   │
   └──────────────┬───────────────────────────┘
                  │
                  ▼
   Response:
   {
     "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
     "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
   }
                  │
                  ▼
   ┌──────────────────────────────────────────┐
   │ Frontend (auth store)                    │
   │                                          │
   │ Stores tokens in:                        │
   │ - localStorage (persistent)              │
   │ - Pinia state (in-memory)                │
   └──────────────────────────────────────────┘

2. USER ACCESSES PROTECTED RESOURCE
   ┌──────────────────────────────────────────┐
   │ Frontend                                 │
   │                                          │
   │ User navigates to /admin/dashboard       │
   └──────────────┬───────────────────────────┘
                  │
                  ▼
   GET /api/projects/
   Headers: {
     "Authorization": "Bearer eyJhbGci..."
   }
                  │
                  ▼
   ┌──────────────────────────────────────────┐
   │ Backend (JWTAuthentication)              │
   │                                          │
   │ 1. Extracts token from Authorization     │
   │ 2. Verifies signature                    │
   │ 3. Checks expiration                     │
   │ 4. If valid, identifies user             │
   └──────────────┬───────────────────────────┘
                  │
                  ▼
   Response: [list of projects]

3. TOKEN EXPIRES (Auto-Refresh)
   ┌──────────────────────────────────────────┐
   │ Frontend makes request with expired token│
   └──────────────┬───────────────────────────┘
                  │
                  ▼
   Backend returns: 401 Unauthorized
                  │
                  ▼
   ┌──────────────────────────────────────────┐
   │ Axios Interceptor (frontend)             │
   │                                          │
   │ Automatically:                           │
   │ 1. Catches 401 error                     │
   │ 2. Sends refresh token to backend        │
   │ 3. Gets new access token                 │
   │ 4. Retries original request              │
   └──────────────────────────────────────────┘
```

### JWT Configuration in Your Project

**Backend** (`backend/settings.py`):

```python
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
}
```

**Frontend** (`frontend/src/services/api.ts`):

```typescript
// Axios interceptor adds token to requests
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})
```

---

## Public vs Protected Endpoints

### Permission Classes

Django REST Framework uses **permission classes** to control access.

**Your Implementation:**

```python
# In projects/views.py
from rest_framework.permissions import IsAuthenticatedOrReadOnly

class ProjectListCreate(APIView):
    permission_classes = [IsAuthenticatedOrReadOnly]

    def get(self, request):
        # Anyone can GET (read)
        ...

    def post(self, request):
        # Only authenticated users can POST (create)
        ...
```

### How It Works

```
┌─────────────────────────────────────────────────────────┐
│          IsAuthenticatedOrReadOnly Logic                 │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  IF request is "safe" (GET, HEAD, OPTIONS):             │
│      → Allow everyone (authenticated or not)            │
│                                                          │
│  ELSE (POST, PUT, PATCH, DELETE):                       │
│      → Check if user is authenticated                   │
│      → If YES: Allow                                    │
│      → If NO: Return 401 Unauthorized                   │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**Safe Methods** (read-only):
- GET - Retrieve data
- HEAD - Get headers only
- OPTIONS - Get supported methods

**Unsafe Methods** (modify data):
- POST - Create
- PUT - Full update
- PATCH - Partial update
- DELETE - Remove

### Your API Endpoints Access Control

| Endpoint | Method | Public | Authenticated | Superuser Only |
|----------|--------|--------|---------------|----------------|
| /api/projects/ | GET | ✅ Yes | ✅ Yes | ✅ Yes |
| /api/projects/:id/ | GET | ✅ Yes | ✅ Yes | ✅ Yes |
| /api/projects/ | POST | ❌ No | ✅ Yes | ✅ Yes |
| /api/projects/:id/ | PUT | ❌ No | ✅ Yes | ✅ Yes |
| /api/projects/:id/ | PATCH | ❌ No | ✅ Yes | ✅ Yes |
| /api/projects/:id/ | DELETE | ❌ No | ✅ Yes | ✅ Yes |
| /api/auth/jwt/create/ | POST | ✅ Yes | N/A | N/A |
| /api/auth/jwt/refresh/ | POST | ✅ Yes | N/A | N/A |

---

## CORS (Cross-Origin Resource Sharing)

### What is CORS?

**CORS** is a security feature in browsers that prevents websites from making requests to different domains.

**The Problem:**

```
Your frontend:  http://localhost:5173
Your backend:   http://localhost:8000
                ↑
                Different ports = Different origins!
```

Without CORS configuration, browsers would block requests from your frontend to your backend.

### How CORS Works

```
┌────────────────────────────────────────────────────────┐
│  Browser (http://localhost:5173)                       │
│                                                         │
│  JavaScript wants to call: http://localhost:8000/api/  │
└──────────────┬──────────────────────────────────────────┘
               │
               ▼
   Browser asks: "Am I allowed to make this request?"
               │
               ▼
┌──────────────────────────────────────────────────────┐
│  Preflight Request (OPTIONS)                          │
│                                                       │
│  Origin: http://localhost:5173                        │
│  Access-Control-Request-Method: GET                   │
└──────────────┬────────────────────────────────────────┘
               │
               ▼
┌──────────────────────────────────────────────────────┐
│  Backend (Django + django-cors-headers)               │
│                                                       │
│  Checks: Is http://localhost:5173 allowed?           │
│          → Yes! It's in CORS_ALLOWED_ORIGINS         │
└──────────────┬────────────────────────────────────────┘
               │
               ▼
   Response Headers:
   Access-Control-Allow-Origin: http://localhost:5173
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE
               │
               ▼
┌──────────────────────────────────────────────────────┐
│  Browser                                              │
│                                                       │
│  "OK, I'm allowed!"                                   │
│  → Makes actual request                               │
└───────────────────────────────────────────────────────┘
```

### CORS Configuration in Your Project

**Backend** (`backend/settings.py`):

```python
INSTALLED_APPS = [
    # ...
    'corsheaders',  # Must be in INSTALLED_APPS
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # MUST be near top
    'django.middleware.security.SecurityMiddleware',
    # ... other middleware
]

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",    # Vite dev server (default)
    "http://127.0.0.1:5173",    # Alternative localhost
    "http://localhost:5174",    # Vite alternate port
    "http://127.0.0.1:5174",
]
```

**Why two entries for each port?**
- `localhost` vs `127.0.0.1` are technically different origins
- Some systems prefer one over the other
- Including both ensures compatibility

---

## Frontend-Backend Communication

### The Complete Flow

Let's trace a complete request from Vue.js frontend to Django backend:

**Scenario: Fetching Projects List**

```
STEP 1: User opens Projects Page
───────────────────────────────────
Frontend: ProjectsView.vue
Location: /projects

Code:
┌────────────────────────────────────────┐
│ onMounted(async () => {                │
│   await fetchProjects()                │
│ })                                     │
└────────────────────────────────────────┘

STEP 2: Fetch Function Calls API Service
─────────────────────────────────────────
Code:
┌────────────────────────────────────────┐
│ const fetchProjects = async () => {    │
│   const response = await axios.get(    │
│     'http://localhost:8000/api/projects/' │
│   )                                    │
│   projects.value = response.data       │
│ }                                      │
└────────────────────────────────────────┘

STEP 3: Axios Makes HTTP Request
─────────────────────────────────
Browser:
┌────────────────────────────────────────┐
│ GET http://localhost:8000/api/projects/│
│ Headers:                               │
│   Origin: http://localhost:5173        │
│   (No Authorization - public endpoint) │
└────────────────────────────────────────┘

STEP 4: CORS Preflight Check
─────────────────────────────
Browser → Backend:
┌────────────────────────────────────────┐
│ OPTIONS /api/projects/                 │
│ Origin: http://localhost:5173          │
└────────────────────────────────────────┘

Backend → Browser:
┌────────────────────────────────────────┐
│ Access-Control-Allow-Origin:           │
│   http://localhost:5173                │
│ Access-Control-Allow-Methods: GET, ... │
└────────────────────────────────────────┘

STEP 5: Actual Request
──────────────────────
Browser → Backend:
┌────────────────────────────────────────┐
│ GET /api/projects/                     │
└────────────────────────────────────────┘

STEP 6: Django URL Routing
──────────────────────────
Django:
┌────────────────────────────────────────┐
│ Check backend/urls.py:                 │
│   path("api/", include("projects.urls"))│
│                                        │
│ Check projects/urls.py:               │
│   path("projects/", ...)              │
│                                        │
│ → Routes to ProjectListCreate.get()   │
└────────────────────────────────────────┘

STEP 7: View Processes Request
───────────────────────────────
Backend: projects/views.py
┌────────────────────────────────────────┐
│ def get(self, request):                │
│   # 1. Query database                  │
│   queryset = Project.objects.all()    │
│                                        │
│   # 2. Serialize to JSON               │
│   serializer = ProjectSerializer(      │
│       queryset, many=True              │
│   )                                    │
│                                        │
│   # 3. Return response                 │
│   return Response(serializer.data)     │
└────────────────────────────────────────┘

STEP 8: Response Sent to Frontend
──────────────────────────────────
Backend → Browser:
┌────────────────────────────────────────┐
│ Status: 200 OK                         │
│ Content-Type: application/json         │
│ Body:                                  │
│ [                                      │
│   {                                    │
│     "id": 1,                           │
│     "name": "Project 1",               │
│     "description": "...",              │
│     "is_active": true,                 │
│     "created_at": "2025-01-15T...",    │
│     "updated_at": "2025-01-15T..."     │
│   },                                   │
│   ...                                  │
│ ]                                      │
└────────────────────────────────────────┘

STEP 9: Frontend Updates UI
────────────────────────────
Frontend: ProjectsView.vue
┌────────────────────────────────────────┐
│ projects.value = response.data         │
│                                        │
│ Vue reactivity system detects change   │
│ → Re-renders template                  │
│ → User sees project cards              │
└────────────────────────────────────────┘
```

### With Authentication (Protected Endpoint)

**Scenario: Creating a Project**

```
Frontend:
POST /api/projects/
Headers: {
  "Authorization": "Bearer eyJhbGciOiJI..."
}
Body: {
  "name": "New Project",
  "description": "Test"
}

Backend:
1. CorsMiddleware: ✅ Origin allowed
2. JWTAuthentication: ✅ Token valid
3. IsAuthenticatedOrReadOnly: ✅ User authenticated
4. View executes: Creates project
5. Returns: 201 Created with project data
```

---

## Complete Application Architecture

### Current Architecture

```
┌──────────────────────────────────────────────────────────────┐
│                         USER                                  │
│                      (Web Browser)                            │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│                   Vue.js 3 Frontend (SPA)                     │
│                   http://localhost:5173                       │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  PUBLIC PAGES (No Auth):                                     │
│  ├─ / ........................... Landing Page              │
│  ├─ /projects ................... Public Projects List      │
│  └─ /about ...................... About Page                │
│                                                               │
│  AUTHENTICATION:                                              │
│  └─ /admin ...................... Login Page                │
│                                                               │
│  PROTECTED PAGES (Auth Required):                             │
│  └─ /admin/dashboard ............ Project Management        │
│                                                               │
│  STATE MANAGEMENT:                                            │
│  ├─ Pinia Store (auth) .......... JWT tokens, user info    │
│  └─ LocalStorage ................ Token persistence         │
│                                                               │
│  API LAYER:                                                   │
│  ├─ Axios Client ................ HTTP requests             │
│  ├─ Request Interceptor ......... Add JWT token             │
│  └─ Response Interceptor ........ Handle 401, refresh token │
│                                                               │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     │  HTTP/HTTPS
                     │  JSON Data
                     │
┌────────────────────▼─────────────────────────────────────────┐
│                Django REST Framework API                      │
│                http://localhost:8000                          │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  MIDDLEWARE STACK:                                            │
│  ├─ CorsMiddleware .............. Enable CORS                │
│  ├─ SecurityMiddleware .......... Security headers           │
│  ├─ SessionMiddleware ........... Session handling           │
│  ├─ AuthenticationMiddleware .... User identification        │
│  └─ ...                                                       │
│                                                               │
│  URL ROUTING:                                                 │
│  ├─ /api/projects/ .............. Project CRUD              │
│  └─ /api/auth/jwt/ .............. JWT endpoints             │
│                                                               │
│  VIEWS:                                                       │
│  ├─ ProjectListCreate ........... GET (public), POST (auth) │
│  └─ ProjectDetail ............... GET (public), PUT/DELETE (auth)│
│                                                               │
│  AUTHENTICATION:                                              │
│  ├─ JWTAuthentication ........... Verify JWT tokens          │
│  └─ IsAuthenticatedOrReadOnly ... Permission check           │
│                                                               │
│  SERIALIZERS:                                                 │
│  └─ ProjectSerializer ........... Python ↔ JSON              │
│                                                               │
└────────────────────┬─────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────┐
│                    SQLite Database                            │
│                      (db.sqlite3)                             │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  TABLES:                                                      │
│  ├─ projects_project ............ Projects data              │
│  ├─ auth_user ................... User accounts              │
│  └─ django_session .............. Sessions                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Request Types

**1. Public Request (View Projects):**
```
Browser → GET /api/projects/ → No token needed → 200 OK
```

**2. Authenticated Request (Create Project):**
```
Browser → POST /api/projects/
        → With Bearer token
        → Token verified
        → 201 Created
```

**3. Failed Auth:**
```
Browser → POST /api/projects/
        → No token or invalid token
        → 401 Unauthorized
```

---

## Updated Conclusion

Congratulations! You now understand:

### Backend Development:
- ✅ Django and DRF fundamentals
- ✅ Models, Serializers, Views, URLs
- ✅ Database design and migrations
- ✅ **JWT authentication implementation**
- ✅ **Permission classes (IsAuthenticatedOrReadOnly)**
- ✅ **CORS configuration for frontend access**
- ✅ **Public vs protected API endpoints**

### Full-Stack Integration:
- ✅ **Frontend-backend communication**
- ✅ **RESTful API design principles**
- ✅ **Authentication flow (login, token storage, refresh)**
- ✅ **Axios interceptors for automatic token handling**
- ✅ **CORS and cross-origin requests**
- ✅ **Single Page Application (SPA) architecture**

### Best Practices:
- ✅ Separation of concerns
- ✅ Security considerations (JWT, permissions)
- ✅ Code organization
- ✅ Error handling
- ✅ Documentation

### Next Steps for Advanced Learning:

**1. Add More Security Features:**
- Rate limiting (throttling)
- HTTPS in production
- Environment variables for secrets
- Password complexity requirements

**2. Enhance API:**
- Pagination for large datasets
- Advanced filtering and searching
- Sorting options
- API versioning

**3. Improve Authentication:**
- Password reset functionality
- Email verification
- Social authentication (Google, GitHub)
- Refresh token rotation

**4. Add More Features:**
- File uploads (images for projects)
- Comments or reviews system
- User profiles
- Notifications

**5. Testing:**
- Unit tests for models
- Integration tests for API
- Frontend component tests
- End-to-end tests

**6. Deployment:**
- PostgreSQL database
- Gunicorn/uWSGI web server
- Nginx reverse proxy
- Docker containerization
- Cloud deployment (AWS, Heroku, DigitalOcean)

**7. Performance:**
- Database query optimization
- Caching (Redis)
- CDN for static files
- Code splitting in frontend

**Remember:**
- Keep practicing by building projects
- Read official documentation
- Learn from errors - they're the best teachers
- Join developer communities
- Contribute to open source

**You've built a complete full-stack application! 🚀**

You now have experience with:
- Backend API development
- Frontend SPA development
- Authentication and authorization
- Database design
- REST API design
- Modern web architecture

**Keep coding and building amazing things!**

---

*This guide has been updated to reflect your complete full-stack Django + Vue.js project. Use it as a reference as you continue learning and building!*
